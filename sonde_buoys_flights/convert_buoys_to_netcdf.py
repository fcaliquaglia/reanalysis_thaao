# -*- coding: utf-8 -*-
"""
Created on Mon Jun  2 09:26:00 2025

@author: FCQ
"""

import pandas as pd
import xarray as xr
import os
import glob
import numpy as np

folder_path_buoys = r"H:\Shared drives\Dati_THAAO\thaao_arcsix\buoys\resource_map_doi_10_18739_A2T14TR46\data"
buoy_files = sorted(glob.glob(os.path.join(
    folder_path_buoys, '2024*processed.csv')))

for buoy_file in buoy_files:
    # Load CSV and parse time
    df = pd.read_csv(buoy_file)

    # Your datetime column (already parsed)
    df['time_stamp'] = pd.to_datetime(
        df['time_stamp'], format='%d-%b-%Y %H:%M:%S')
    # Replace zeros with NaN
    df.loc[df['latitude'] == 0, 'latitude'] = np.nan
    df.loc[df['longitude'] == 0, 'longitude'] = np.nan

    df = df.dropna(subset=['time_stamp', 'latitude',
                   'longitude']).reset_index(drop=True)

    # Define your reference time (e.g., the first timestamp or a fixed datetime)
    ref_time = pd.Timestamp(df['time_stamp'][0])

    # Calculate the difference in seconds between each timestamp and the reference
    df['time_seconds'] = (df['time_stamp'] - ref_time).dt.total_seconds()

    n_obs = len(df)
    trajectory_id = os.path.basename(buoy_file).split('.')[0]

    # Prepare data arrays with an extra trajectory dimension (size 1)
    def expand_dim(arr):
        return np.expand_dims(arr.values, axis=0)  # shape (1, n_obs)

    inc = df["air_temp"]*np.nan
    if 'incident' in df.columns:
        inc = df["incident"]

    refl = df["air_temp"]*np.nan
    if 'reflected' in df.columns:
        refl = df["reflected"]
        
    ds = xr.Dataset(
        data_vars=dict(
            air_temp=(["trajectory", "obs"], expand_dim(df["air_temp"])),
            incident=(["trajectory", "obs"], expand_dim(inc)),
            reflected=(["trajectory", "obs"], expand_dim(refl)),
            air_pressure=(["trajectory", "obs"],
                          expand_dim(df["air_pressure"])),
            Surface_Position=(["trajectory", "obs"],
                              expand_dim(df["Surface_Position"])),
            Bottom_Position=(["trajectory", "obs"],
                             expand_dim(df["Bottom_Position"])),
            snow_depth=(["trajectory", "obs"], expand_dim(df["snow_depth"])),
            Ice_Thickness=(["trajectory", "obs"],
                           expand_dim(df["Ice_Thickness"])),
            water_temp=(["trajectory", "obs"], expand_dim(df["water_temp"])),
            surface_distance=(["trajectory", "obs"],
                              expand_dim(df["surface_distance"])),
            bottom_distance=(["trajectory", "obs"],
                             expand_dim(df["bottom_distance"])),
            slip_offset=(["trajectory", "obs"], expand_dim(df["slip_offset"])),
            Temp_Derived_Surface_Position=(["trajectory", "obs"], expand_dim(
                df["Temp-Derived_Surface_Position"])),
            Ice_Surface_Position=(["trajectory", "obs"],
                                  expand_dim(df["Ice_Surface_Position"])),
        ),
        coords=dict(
            trajectory=[trajectory_id],  # dimension length 1
            obs=np.arange(n_obs),
            time=(["trajectory", "obs"], expand_dim(df['time_seconds'])),
            latitude=(["trajectory", "obs"], expand_dim(df["latitude"])),
            longitude=(["trajectory", "obs"], expand_dim(df["longitude"])),
        ),
        attrs=dict(
            title="Trajectory data for buoys 2024C",
            featureType="trajectory",
            Conventions="CF-1.8",
            institution="Generated by Filippo Cal√¨ Quaglia"
        )
    )

    # Add CF standard attributes
    ds['time'].attrs.update({
        'standard_name': 'time',
        'long_name': 'Time of measurement',
        'calendar': 'proleptic_gregorian',
        'axis': 'T'
    })
    ds['time'].attrs['units'] = 'seconds since ' + \
        df['time_stamp'][0].strftime('%Y-%m-%d %H:%M:%S')

    ds['latitude'].attrs.update({
        'standard_name': 'latitude',
        'units': 'degrees_north',
        'long_name': 'Latitude',
        'axis': 'Y',
        '_CoordinateAxisType': 'Lat'
    })

    ds['air_temp'].attrs.update({
        'standard_name': 'air_temperature',
        'units': 'degree_Celsius',
        'long_name': 'Air Temperature'
    })

    ds['incident'].attrs.update({
        'long_name': 'Incident Radiation',
        'units': 'W/m^2',
        'comment': 'Downwelling shortwave radiation'
    })

    ds['reflected'].attrs.update({
        'long_name': 'Reflected Radiation',
        'units': 'W/m^2',
        'comment': 'Upwelling shortwave radiation'
    })

    ds['longitude'].attrs.update({
        'standard_name': 'longitude',
        'units': 'degrees_east',
        'long_name': 'Longitude',
        'axis': 'X',
        '_CoordinateAxisType': 'Lon'
    })
    
    # Add coordinate axis types for obs dimension
    ds['obs'].attrs.update({
        'long_name': 'Observation number along the trajectory',
    })
    
    ds['air_temp'].attrs.update({
        'standard_name': 'air_temperature',
        'units': 'degree_Celsius',
        'long_name': 'Air Temperature'
    })
    
    ds['air_pressure'].attrs.update({
        'standard_name': 'air_pressure',
        'units': 'hPa',
        'long_name': 'Air Pressure'
    })
    
    ds['Surface_Position'].attrs.update({
        'long_name': 'Surface Position',
        'units': 'meters',
        'comment': 'Position of the ice surface relative to a reference'
    })
    
    ds['Bottom_Position'].attrs.update({
        'long_name': 'Bottom Position',
        'units': 'meters',
        'comment': 'Position of the ice bottom relative to a reference'
    })
    
    ds['snow_depth'].attrs.update({
        'standard_name': 'snow_depth',
        'units': 'meters',
        'long_name': 'Snow Depth on Ice Surface'
    })
    
    ds['Ice_Thickness'].attrs.update({
        'standard_name': 'sea_ice_thickness',
        'units': 'meters',
        'long_name': 'Thickness of Sea Ice'
    })
    
    ds['water_temp'].attrs.update({
        'standard_name': 'sea_water_temperature',
        'units': 'degree_Celsius',
        'long_name': 'Temperature of Sea Water beneath Ice'
    })
    
    ds['surface_distance'].attrs.update({
        'long_name': 'Distance to Ice Surface',
        'units': 'meters',
        'comment': 'Distance measurement to ice surface from sensor'
    })
    
    ds['bottom_distance'].attrs.update({
        'long_name': 'Distance to Ice Bottom',
        'units': 'meters',
        'comment': 'Distance measurement to ice bottom from sensor'
    })
    
    ds['slip_offset'].attrs.update({
        'long_name': 'Slip Offset',
        'units': 'meters',
        'comment': 'Offset related to ice slip or displacement'
    })
    
    ds['Temp_Derived_Surface_Position'].attrs.update({
        'long_name': 'Temperature Derived Surface Position',
        'units': 'meters',
        'comment': 'Surface position derived from temperature data'
    })
    
    ds['Ice_Surface_Position'].attrs.update({
        'long_name': 'Ice Surface Position',
        'units': 'meters',
        'comment': 'Position of the ice surface as measured'
    })

    # Coordinates attributes
    ds['time'].attrs.update({
        'standard_name': 'time',
        'long_name': 'Time of Observation',
        'axis': 'T'
    })
    
    ds['latitude'].attrs.update({
        'standard_name': 'latitude',
        'units': 'degrees_north',
        'long_name': 'Latitude',
        'axis': 'Y'
    })
    
    ds['longitude'].attrs.update({
        'standard_name': 'longitude',
        'units': 'degrees_east',
        'long_name': 'Longitude',
        'axis': 'X'
    })
    
    ds['trajectory'].attrs.update({
        'long_name': 'Trajectory Identifier'
    })
    
    ds['obs'].attrs.update({
        'long_name': 'Observation Index'
    })
    
    # Save NetCDF file
    out_filename = os.path.splitext(os.path.basename(buoy_file))[0] + '.nc'
    out_path = os.path.join(folder_path_buoys, out_filename)
    ds.to_netcdf(out_path, format='NETCDF4', engine='netcdf4')
    
    print(f"CF-compliant NetCDF saved at: {out_path}")
